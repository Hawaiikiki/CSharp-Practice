// See https://aka.ms/new-console-template for more information


using System;
/*
1. What are the six combinations of access modifier keywords and what do they do?

public: accessible from everywhere in a project without any restriction
private: accessible only inside a class
protected: accessible inside the class and in all derived(child) classes
internal: access is limited exclusively to classes defined within the current project assembly
protected internal: accessible within same assembly or in a derived class in other assemblies
private protected: accessible inside the containing class or derived class in the same assembly

* assembly: a file that is automatically generated by the compiler upon successful compilation of every .NET application. Can be Dyanmic Link Library (DLL) or EXE file.

2. What is the difference between the static, const, and readonly keywords when applied to a type member?

Static: Shared by all the class objects
- Used to specify a static member --> static members are common to all the objects and they do not tie to a specific object
- Keyword can be used with [classes, fields, methods, properties, operators, events, and constructors]
- Cannot be used with indexers, destructors, or types other than classes
- If static keyword is applied to a class, *All members of the class must be static*
- Static constructor cannot be parametrized
- Access modifiers cannot be applied on Static constructor => it's always a public default constructor which is used to initialize static fields of the class

Const: 
- Constant fields or local variables must be assigned a value at the time of declaration and cannot be modified after that. 
- By default, it's static.
- Const field is a compile-time constant (void Caclulate(int Z) { const int x = 10 + Z; // not allowed}
- Use when we are sure it would not be changed

Readonly: Cannot be modified
- Readonly field can be intialized either at the time of declaration of within the constructor of the same class { readonly int X = 10; readonly int x1;}
- Readonly fields can be used for run-time constants
- Can specify a readonly field as static since by default it is not static
- Readonly keyword can be applied to both value type and reference type
- Delegate and event could not be readonly
- Use when we want to make a field constant at run time public ConstructorName(int x1) { x1 = x1; // initialized at run time}

3. What does a constructor do?

- Constructor is used to create an object of the class and initialize class members.

4. Why is the partial keyword useful?

- Partial is used to split the definition of a class, a struct, an interface, or a method over two or more source files. Each source file contains a section of the type
or method definition. All parts are combined when the application is compiled
- When working on large projects, spreading a class over separate files enables multiple people to work on it at the same time.

public partial class Employee { } 

5. What is a tuple?

- Tuple feature provides concise syntax to group multiple data elements in a lightweight data structure. Often, we use tuples as a method return type.
(double, int) t = (4.5, 3);
(int min, int max) FindMinMax(int[] input){
    return (min, max);
}

6. What does the C# record keyword do?

- record is a new reference type that we can create instead of classes or structs. We can define records as value types, and they are distinct from classes in that
record types are value based equality. 
- We use a record when an instance of a class is entirely defined by the public data it contains and has no unique identity of its own.
- Recrod is basically just an immutable bag of data. 

7. What does overloading and overriding mean?

- Overloading: Multiple methods in the same class with same method name and access modifier, but different input or output parameters. It's a compile time polymorphism.

- Overriding:  Happens between base and derived class. We have same method signature (same name + input params) but different implementation in derived class. It's a runtime polymorphism

8. What is the difference between a field and a property?

- Properties expose fields. We usually keep our fields private to a class and acceessed only via get and set properties.
- Properties provide a level of abstraction allowing us to change the fields while not affecting the external way they are accessed by the things that use our class.
- So we can think it as properties are used to wrap fields in the class.

9. How do you make a method parameter optional?

- Each optional parameter has a default value as part of its definition. So if no argument is sent for that parameter, the default value is used. 
- Here, default value must be one of the following types of expressions

* a constant expression
* an expression of the form new ValType(), ValType is a value type such as enum or struct
* an expression of the form default(ValType)

public void ExampleMethod(int required, string optionalstr = "default string", int optionalint = 10)
anExample.ExampleMethod(3, optionalint: 4); // works
//anExample.ExampleMethod(3, ,4); // doesn't work

10. What is an interface and how is it different from abstract class?

- Interface is a collection of methods which are by default abstract and public. Interface will be implemented by the derived class.
Differences:
1) One class can only inherit from one abstract class, but can implement multiple interfaces
2) Abstract class can have both abstract & non-abstract methods, but interface methods are by default abstract
3) Abstract class can have instantiated constructor and fields, but interface cannot have them

11. What accessibility level are members of an interface?

- The default access is public for an interface and its methods

12. True/False. Polymorphism allows derived classes to provide different implementations of the same method.

True

13. True/False. The override keyword is used to indicate that a method in a derived class is providing its own implementation of a method.

True: Override modifier extends the base class virtual method

14. True/False. The new keyword is used to indicate that a method in a derived class is providing its own implementation of a method.

False: New modifier hides an accessible base class method

15. True/False. Abstract methods can be used in a normal (non-abstract) class. 

False (only abstract class)

16. True/False. Normal (non-abstract) methods can be used in an abstract class. 

True

17. True/False. Derived classes can override methods that were virtual in the base class. 

True

18. True/False. Derived classes can override methods that were abstract in the base class. 

True (have to override)

19. True/False. In a derived class, you can override a method that was neither virtual nor abstract in the base class.

False

20. True/False. A class that implements an interface does not have to provide an implementation for all of the members of the interface.

False: when we inherit an interface, we must implement all its methods ( not required for abstract class)

21. True/False. A class that implements an interface is allowed to have other members that aren’t defined in the interface.

True

22. True/False. A class can have more than one base class.

True

23. True/False. A class can implement more than one interface.

True

 */

// Working with Methods

// 1. generate + reverse + print number array

//int[] GenerateNumbers()
//{
//    List<int> nums = new List<int>();
//    Console.WriteLine("Enter numbers to create an array. If input is not a number, it stops creating array");
//    //for (int i = 0; i < 10; i++)
//    //{
//    //    string userInput = Console.ReadLine();
//    //    int userInt;
//    //    if (int.TryParse(userInput, out userInt))
//    //    {
//    //        nums.Add(userInt);
//    //    }
//    //}

//    int userInt;
//    while (int.TryParse(Console.ReadLine(), out userInt))
//    {
//        nums.Add(userInt);

//    }

//    return nums.ToArray();
//}

//int[] Reverse(int[] arr)
//{
//    Array.Reverse(arr);
//    return arr;
//}

//void PrintNumbers(int[] arr)
//{
//    string s = string.Join(", ", arr);
//    Console.WriteLine(s);
//    // can use foreach method to go through each element in the array and print
//    // we can write first element by it self and write additional elemtns separated by ", "

//}
//int[] numbers = GenerateNumbers();
//Reverse(numbers);
//PrintNumbers(numbers);

// 2. Fibonacci f(n) = f(n-1) + f(n-2)

//int Fibonacci(int n)
//{
//    if (n == 1) return 1;
//    if (n == 2) return 1;
//    return Fibonacci(n - 1) + Fibonacci(n - 2);
//}

//Console.WriteLine(Fibonacci(6));
//Console.WriteLine(Fibonacci(10));

// Designing and Building Classes using Object-Oriented Principles

// 1. Demonstrate use of four basic principles

// Abstraction

// Encapsulation

// Inheritance

// Polymorphism
//public class MobilePhone // each class is an example of encapsulation. We put related fields and methods into one bag
//{
//    string modelName; 
//    string phoneNumber;
//    public MobilePhone()
//    {
//        Console.WriteLine("Mobile Phone object created");
//    }
//    public void Calling() { } // these methods are examples of abstraction. It tells what it does but not how it does.
//    public void SendMsg() { }
//}
//public class IPhone : MobilePhone // this is an example of Inheritance. We can inherit predefined class to reuse the codes
//{
//    public void Calling() { Console.WriteLine("Iphone calling"); } // this is an example of polymorphism. 
//    public void SendMsg() { Console.WriteLine("Iphone sending msg"); }

//}
//public class Android : MobilePhone
//{
//    public void Calling() { Console.WriteLine("Android calling"); } // Polymorphism allows us to implement method with same name different for each derived class
//    public void SendMsg() { Console.WriteLine("Android sending msg"); }
//}

// 2. Abstraction: define different classes for each person type

//public class Person
//{
//    string name;
//    int age;
//}
//public class Student
//{
//    string name;
//    int age;
//    string classroom;
//    public Student(string name, int age,string classroom)
//    {
//        this.name = name;
//        this.age = age;
//        this.classroom = classroom;
//    }
//    public void CheckClassroom()
//    {
//        Console.WriteLine("Student's classroom is " + this.classroom);
//    }
//}

//public class Instructor
//{
//    string name;
//    int age;
//    string subject;
//    public Instructor(string name, int age, string subject)
//    {
//        this.name = name;
//        this.age = age;
//        this.subject = subject;
//    }
//    public void CheckSubject()
//    {
//        Console.WriteLine("Instructor teaches " + this.subject);
//    }
//}

// 3. Encapsulation: hide details private

//public class backpack
//{
//    private string book;
//    private string pen;
//    private string laptop;
//    private string waterBottle;

//}

// 4. Inheritance
//namespace Inherit
//{
//    public class Person
//    {
//        public string name;
//        public int age;
//        public Person(string name, int age)
//        {
//            this.name = name;
//            this.age = age;
//        }
//    }
//    public class Student : Person
//    {
//        //string name;
//        //int age;
//        public string classroom;
//        public Student(string name, int age, string classroom) : base(name, age)
//        {
//            this.classroom = classroom;
//        }
//        public void CheckClassroom()
//        {
//            Console.WriteLine("Student's classroom is " + this.classroom);
//        }
//    }

//    public class Instructor : Person
//    {
//        //string name;
//        //int age;
//        public string subject;
//        public Instructor(string name, int age, string subject) : base(name, age)
//        {

//            this.subject = subject;
//        }
//        public void CheckSubject()
//        {
//            Console.WriteLine("Instructor teaches " + this.subject);
//        }
//    }
//}

// 5. Polymorphism: create virtual methods to be overridden

//namespace Inherit
//{
//    public class Person
//    {
//        public string name;
//        public int age;
//        public Person(string name, int age)
//        {
//            this.name = name;
//            this.age = age;
//        }
//        public virtual void whoAreyou()
//        {
//            Console.WriteLine($"I am a normal person with name {this.name}");
//        }
//    }
//    public class Student : Person
//    {
//        //string name;
//        //int age;
//        public string classroom;
//        public Student(string name, int age, string classroom) : base(name, age)
//        {
//            this.classroom = classroom;
//        }
//        public void CheckClassroom()
//        {
//            Console.WriteLine("Student's classroom is " + this.classroom);
//        }
//        public override void whoAreyou()
//        {
//            Console.WriteLine($"I am a normal student with name {this.name}");
//        }
//    }

//    public class Instructor : Person
//    {
//        //string name;
//        //int age;
//        public string subject;
//        public Instructor(string name, int age, string subject) : base(name, age)
//        {

//            this.subject = subject;
//        }
//        public void CheckSubject()
//        {
//            Console.WriteLine("Instructor teaches " + this.subject);
//        }
//        public override void whoAreyou()
//        {
//            Console.WriteLine($"I am a normal instructor with name {this.name}");
//        }
//    }
//}

// 6. Create Interfaces

// 7. Create Class

using Day6;
//Color c = new Color(10, 50, 100);
//Console.WriteLine(c.GreyScale());
//Console.WriteLine(c.Red);
//Console.WriteLine(c.Green);

Color c1 = new Color(10, 50, 100);
Color c2 = new Color(100, 200, 50);

Ball b1 = new Ball(10, c1);
Ball b2 = new Ball(100, c2);
b1.Throw();
b2.Throw();
for (int i = 0; i < 5; i++)
{
    b1.Throw();
}
Console.WriteLine(b1.NumThrown);
Console.WriteLine(b2.NumThrown);

b1.Pop();
Console.WriteLine(b1.Size);
Console.WriteLine(b2.Size);
b1.Throw();

Ball b3 = new Ball(0, c1);